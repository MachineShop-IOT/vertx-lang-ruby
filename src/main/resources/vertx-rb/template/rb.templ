@code{
  /* todo : have this in codegen and not here */
  def dashedSeparatedNameToCamelCase(name) {
    var index = name.indexOf("-");
    var head;
    var tail;
    if (index == -1) {
      head = name;
      tail = "";
    } else {
      head = name.substring(0, index);
      tail = dashedSeparatedNameToCamelCase(name.substring(index + 1));
    }
    return Character.toUpperCase(head.charAt(0)) + head.substring(1) + tail;
  }
}

@code{
  def genRubyClassFqn(type) {
    return type.module.getName(CASE_CAMEL) + "::" + type.simpleName;
  }
  def genJavaClassFqn(type) {
    return "Java::" + CASE_CAMEL.format(CASE_QUALIFIED.parse(type.packageName)) + "::" + type.simpleName;
  }
}

@code{
  def typeCheckPred(name, type) {
    var kind = type.kind;
    if (kind == CLASS_STRING || kind == CLASS_ENUM) {
      return name + " != nil && " + name + ".class == String";
    } else if (kind.basic) {
      var typeName = type.name;
      if (typeName == "byte" || typeName == "java.lang.Byte" ||
          typeName == "short" || typeName == "java.lang.Short" ||
          typeName == "int" || typeName == "java.lang.Integer" ||
          typeName == "char" || typeName == "java.lang.Character" ||
          typeName == "long" || typeName == "java.lang.Long") {
        return name + " != nil && " + name + ".class == Fixnum";
      }
      if (typeName == "float" || typeName == "java.lang.Float" ||
          typeName == "double" || typeName == "java.lang.Double") {
        return name + " != nil && " + name + ".class == Float";
      }
      if (typeName == "boolean" || typeName == "java.lang.Boolean") {
        return name + " != nil && (" + name + ".class == TrueClass || " + name + ".class == FalseClass)";
      }
    } else if (kind == CLASS_OBJECT) {
      return name + " != nil && (" + name + ".class == String  ||" + name + ".class == Hash || " + name + ".class == Array)"
    } else if (kind == CLASS_API) {
      return name + " != nil && " + name + ".class.method_defined?(:j_del)";
    } else if (kind == CLASS_HANDLER) {
      return name + " != nil && " + name + ".class == Proc";
    } else if (kind == CLASS_OPTIONS || kind == CLASS_JSON_OBJECT) {
      return name + " == nil || " + name + ".class == Hash";
    } else if (kind == CLASS_JSON_ARRAY) {
      return name + " == nil || " + name + ".class == Array";
    } else if (kind == CLASS_LIST) {
      return name + " != nil && " + name + ".class == Array";
    } else if (kind == CLASS_SET) {
      return name + " != nil && " + name + ".class == Set";
    } else if (kind == CLASS_MAP) {
      return name + " != nil && " + name + ".class == Hash";
    }
    return "false";
  }
}

@code{
  def genMethodCall(method,generic) {
    var s = "";
    var index = 1;
    if (method.params.size() > 0) {
      s = "";
      for (param : method.params) {
        if (s.length() > 0) {
          s += ",";
        }
        var name = "";
        if (generic) {
          name = 'param_' + index;
        } else {
          name = param.getName(CASE_SNAKE);
        }
        s += genConvParam(param.type, name);
        index += 1;
      }
      s = "(" + s + ")";
    }
    return (method.staticMethod ? genJavaClassFqn(type.raw) : "@j_del") + "." + method.getName() + s;
  }
}

@code{
  def genConvParam(type, name) {
    var kind = type.kind;
    if (kind.basic) {
      if (type.name == "byte" || type.name == "java.lang.Byte") {
        return "Vertx::Util::Utils.to_byte(" + name + ")";
      } else if (type.name == "short" || type.name == "java.lang.Short") {
        return "Vertx::Util::Utils.to_short(" + name + ")";
      } else if (type.name == "integer" || type.name == "java.lang.Integer") {
        return "Vertx::Util::Utils.to_integer(" + name + ")";
      } else if (type.name == "float" || type.name == "java.lang.Float") {
        /* not tested */
        return "Vertx::Util::Utils.to_float(" + name + ")";
      } else if (type.name == "double" || type.name == "java.lang.Double") {
        /* not tested */
        return "Vertx::Util::Utils.to_double(" + name + ")";
      } else {
        return name;
      }
    } else if (kind == CLASS_HANDLER) {
      var eventType = type.args[0];
      var eventKind = eventType.kind;
      if (eventKind.basic || eventKind == CLASS_OPTIONS || eventKind.collection || eventKind == CLASS_API ||
          eventKind == CLASS_THROWABLE || eventKind == CLASS_OBJECT || eventKind.json) {
        return "(Proc.new { |event| " + name + ".call(" + genConvReturn(eventType, "event") + ") })";
      } else if (eventKind == CLASS_VOID) {
        return name;
      } else if (eventKind == CLASS_ASYNC_RESULT) {
        var resultType = eventType.args[0];
        var resultKind = resultType.kind;
        if (resultKind.basic || resultKind == CLASS_OPTIONS || resultKind.collection || resultKind == CLASS_API ||
            resultKind == CLASS_OBJECT || resultKind.json) {
          return "(Proc.new { |ar| " + name + ".call(ar.failed ? ar.cause : nil, ar.succeeded ? " + genConvReturn(resultType, "ar.result") + " : nil) })";
        } else if (resultKind == CLASS_VOID) {
          return "(Proc.new { |ar| " + name + ".call(ar.failed ? ar.cause : nil) })";
        }
      }
    } else if (kind == CLASS_API) {
      return name + ".j_del";
    } else if (kind == CLASS_OBJECT) {
      return "Vertx::Util::Utils.to_object(" + name + ")";
    } else if (kind == CLASS_OPTIONS) {
      return name + " != nil ? " + genJavaClassFqn(type) + ".new(Vertx::Util::Utils.to_json_object(" + name + ")) : nil";
    } else if (kind == CLASS_JSON_OBJECT) {
      return name + " != nil ? " + "Vertx::Util::Utils.to_json_object(" + name + ") : nil";
    } else if (kind == CLASS_JSON_ARRAY) {
      return name + " != nil ? " + "Vertx::Util::Utils.to_json_array(" + name + ") : nil";
    } else if (kind == CLASS_ENUM) {
      return genJavaClassFqn(type) + ".valueOf(" + name + ")";
    } else if (kind == CLASS_LIST) {
      var elementType = type.args[0];
      return name + ".map { |element| " + genConvParam(elementType, "element") + " }";
    } else if (kind == CLASS_SET) {
      var elementType = type.args[0];
      return "Java::JavaUtil::LinkedHashSet.new(" + name + ".map { |element| " + genConvParam(elementType, "element") + " })";
    } else if (kind == CLASS_MAP) {
      var valueType = type.args[1];
      return "Hash[" + name + ".map { |k,v| [k," + genConvParam(valueType, "v") + "] }]";
    }
    return "nil";
  }
}

@code{
  def genConvReturn(type, expr) {
    if (type.name.equals("void")) {
      return expr;
    } else {
      var kind = type.kind;
      if (kind.basic || kind == CLASS_THROWABLE) {
        return expr;
      } else if (kind == CLASS_OPTIONS) {
        return "JSON.parse(" + expr + ".toJson.encode)";
      } else if (kind == CLASS_LIST) {
        var elementType = type.args[0];
        return expr + ".to_a.map { |elt| " + genConvReturn(elementType, "elt") + " }";
      } else if (kind == CLASS_SET) {
        var elementType = type.args[0];
        return expr + ".to_set.map! { |elt| " + genConvReturn(elementType, "elt") + " }";
      } else if (kind == CLASS_MAP) {
        var valueType = type.args[1];
        var valueKind = valueType.kind;
        var toJava = "to_object";
        if (valueKind == CLASS_JSON_OBJECT) {
          toJava = "to_json_object";
        } else if (valueKind == CLASS_JSON_ARRAY) {
          toJava = "to_json_array";
        } else if (valueKind.basic) {
          if (valueKind == CLASS_STRING) {
            toJava = "to_string";
          } else if (valueType.name == 'java.lang.Long') {
            toJava = "to_long";
          } else if (valueType.name == 'java.lang.Integer') {
            toJava = "to_integer";
          } else if (valueType.name == 'java.lang.Short') {
            toJava = "to_short";
          } else if (valueType.name == 'java.lang.Byte') {
            toJava = "to_byte";
          } else if (valueType.name == 'java.lang.Character') {
            toJava = "to_character";
          } else if (valueType.name == 'java.lang.Boolean') {
            toJava = "to_boolean";
          } else if (valueType.name == 'java.lang.Float') {
            toJava = "to_float";
          } else if (valueType.name == 'java.lang.Double') {
            toJava = "to_double";
          }
        }
        return "Java::IoVertxLangJruby::Helper.adaptingMap(" + expr + ", Proc.new { |val| Vertx::Util::Utils.from_object(val) }, Proc.new { |val| Vertx::Util::Utils." + toJava + "(val) })";
      } else if (kind == CLASS_API) {
        return type.raw.module.getName(CASE_CAMEL) + "::"  + type.raw.simpleName + (type.raw.concrete ? "" : "Impl") + ".new(" + expr + ")";
      } else if (kind.json) {
        return expr + " != nil ? JSON.parse(" + expr + ".encode) : nil";
      } else if (kind == CLASS_OBJECT) {
        return "Vertx::Util::Utils.from_object(" + expr + ")";
      } else if (kind == CLASS_ENUM) {
        return expr + ".name";
      }
      return "nil";
    }
  }
}

@code{
  def genIndent() {
    var builder = new java.lang.StringBuilder('  ');
    for (i:_trie.size()) {
      builder.append('    ');
    }
    return builder.toString();
  }
}


@code{
  /* Append an entry Iterator<ParamInfo> to a trie Map<ParamInfo, Map<ParamInfo, Map<...>>> */
  def trieAppend(trie, entry) {
    if (entry.hasNext()) {
      var first = entry.next();
      if (!trie.containsKey(first.type)) {
        trie.put(first.type, new java.util.HashMap());
      }
      return trieAppend(trie.get(first.type), entry);
    } else {
      return trie;
    }
  }
  /*
    0 : empty
    1 : linear
    2 : multiarg
  */
  def trieKind(trie) {
    if (trie.isEmpty()) {
      return 0;
    } else if (trie.size() == 1) {
      var kind = trieKind(trie.get(trie.keySet().iterator().next()));
      if (kind == 2) {
        return 2;
      }
      return 1;
    } else {
      return 2;
    }
  }
  def trieHeight(trie) {
    if (trie.isEmpty()) {
      return 0;
    } else {
      var max = 0;
      for (child : trie.values()) {
        var height = trieHeight(child) + 1;
        if (height > max) {
          max = height;
        }
      }
      return max;
    }
  }
}

@declare{'foobarjuu'}
@if{method.fluent}
@{indent}@{genMethodCall(method,generic)}\n
@{indent}@if{!last}return @end{}self\n
@else{}
	@if{method.cacheReturn}
		@code{cacheKey="@cached_" + method.getName(CASE_SNAKE)}
		@code{cacheDecl=cacheKey + " = "}
		@{indent}  if @{cacheKey} != nil\n
		@{indent}    return @{cacheKey}\n
		@{indent}  end\n
	@else{}
		@code{cacheDecl=""}
	@end{}
@{indent}@if{!last}return @end{}@{cacheDecl}@{genConvReturn(method.returnType, genMethodCall(method,generic))}\n
@end{}
@end{}

require 'vertx/util/utils.rb'\n

@declare{'initializer'}
    def initialize(j_del)\n
	@if{callSuper}
      super(j_del)\n
	@end{}
      @j_del = j_del\n
    end\n
    def j_del\n
      @j_del\n
    end\n
@end{}

# Generated from @{type.name}\n
module @{dashedSeparatedNameToCamelCase(type.raw.moduleName)}\n

@if{concrete}
  class @{type.raw.simpleName}@if{concreteSuperTypes.size() == 1} < @{genRubyClassFqn(concreteSuperTypes[0].raw)}@end{}\n
	@foreach{abstractSuperType:abstractSuperTypes}
    include @{genRubyClassFqn(abstractSuperType.raw)}\n
	@end{}
	@includeNamed{'initializer';callSuper=concreteSuperTypes.size() == 1}
@else{}
  module @{type.raw.simpleName}\n
	@foreach{superType:superTypes}
    include @{genRubyClassFqn(superType.raw)}\n
	@end{}
@end{}

	@foreach{methods:methodsByName.values()}

		@code{methodName=methods[0].getName(CASE_SNAKE)}
		@code{methodDecl=(methods[0].staticMethod ? "self." : "") + methodName}
		@code{trie = new java.util.HashMap()}
		@code{methodMap = new java.util.IdentityHashMap()}
		@foreach{method:methods}
			@code{methodMap.put(trieAppend(trie, method.params.iterator()), method)}
		@end{}
		@code{kind = trieKind(trie)}

		@if{kind == 0 || kind == 1}
		@code{lastMethod=methods[methods.size() - 1]}
    def @{methodDecl}(
		@foreach{param:lastMethod.params}
			@{param.getName(CASE_SNAKE)}@if{!methods[0].params.contains(param)}=nil@end{}
		@end{","}
		)\n
		@code{paramCount=0}
		@code{margin=""}
		@foreach{param:lastMethod.params}
      @{margin}if @{typeCheckPred(param.getName(CASE_SNAKE), param.type)}\n
			@code{margin+="  "}
			@code{paramCount++}
		@end{}
		@foreach{param:lastMethod.params}
			@code{margin=margin.substring(2)}
			@code{found=null}
			@foreach{method:methods}
				@if{method.params.size() == paramCount}
					@code{found=method}
				@end{}
			@end{}
			@if{found!=null}
				@includeNamed{'foobarjuu';method=found;indent="        " + margin;generic=false;last=false}
			@else{}
        @{margin}raise ArgumentError, 'dispatch error'\n
			@end{}
      @{margin}end\n
			@code{paramCount--}
		@end{}
		@if{methods[0].params.empty}
			@includeNamed{'foobarjuu';method=methods[0];indent="      ";generic=false;last=true}
		@else{}
      raise ArgumentError, 'dispatch error'\n
		@end{}
    end\n
		@else{}

@code{_trie=new java.util.LinkedList()}

@declare{'foobar'}
	@code{_trie.addLast(trie)}
	@if{trie.size() > 0}
		@foreach{entry:trie.entrySet()}
			@{genIndent()}  if @{typeCheckPred('param_' + _trie.size(), entry.key)}\n
			@code{trie=entry.value}
			@includeNamed{'foobar'}
			@{genIndent()}  end\n
		@end{}
	@end{}
	@code{trie=_trie.removeLast()}
	@if{methodMap.containsKey(trie)}
		@includeNamed{"foobarjuu";method=methodMap.get(trie);indent=("    " + genIndent());generic=true;last=false}
	@else{}
		@{genIndent()}    raise ArgumentError, 'dispatch error'\n
	@end{}
@end{}

    def @{methodDecl}(@foreach{index:trieHeight(trie)}param_@{(index + 1)}=nil@end{","})\n
			@includeNamed{'foobar'}
    end\n

		@end{}

	@end{}

  end\n

@comment{"The mixin implementing the class for abstract interfaces"}
@if{!concrete}
  class @{type.raw.simpleName}Impl\n
    include @{type.raw.simpleName}\n
@includeNamed{'initializer';callSuper=false}
  end\n
@end{}

end\n